<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="--react redux Immutable reselect," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="本篇文章将聚焦Immutable与Redux,reselect的项目实践，将从多方面阐述Immutable及Redux：包括什么是Immutable，为什么需要使用Immutable，Immutable.js与React，Redux及reselect的组合实践及优化，最后总结使用Immutable可能遇到的一些问题及解决方式。">
<meta name="keywords" content="--react redux Immutable reselect">
<meta property="og:type" content="article">
<meta property="og:title" content="Immutable.js与React,Redux及reselect的实践">
<meta property="og:url" content="http://ZheningLin.github.io/2019/02/20/react-practice/index.html">
<meta property="og:site_name" content="Jacob&#39;s Notes">
<meta property="og:description" content="本篇文章将聚焦Immutable与Redux,reselect的项目实践，将从多方面阐述Immutable及Redux：包括什么是Immutable，为什么需要使用Immutable，Immutable.js与React，Redux及reselect的组合实践及优化，最后总结使用Immutable可能遇到的一些问题及解决方式。">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-practice/bg.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-practice/1.png">
<meta property="og:updated_time" content="2019-02-20T10:17:28.806Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Immutable.js与React,Redux及reselect的实践">
<meta name="twitter:description" content="本篇文章将聚焦Immutable与Redux,reselect的项目实践，将从多方面阐述Immutable及Redux：包括什么是Immutable，为什么需要使用Immutable，Immutable.js与React，Redux及reselect的组合实践及优化，最后总结使用Immutable可能遇到的一些问题及解决方式。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-practice/bg.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '7TPGXTD83V',
      apiKey: '3c064d4a40968fd9c426dab1bb9ed2ab',
      indexName: 'test',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ZheningLin.github.io/2019/02/20/react-practice/"/>





  <title>Immutable.js与React,Redux及reselect的实践 | Jacob's Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d8e4fd1e3f6fbb2379d52ea3f14d4e13";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jacob's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Quick notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ZheningLin.github.io/2019/02/20/react-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacob">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Immutable.js与React,Redux及reselect的实践</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-20T16:49:35+08:00">
                2019-02-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日志-二级目录/" itemprop="url" rel="index">
                    <span itemprop="name">-日志 -二级目录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/20/react-practice/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/02/20/react-practice/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/02/20/react-practice/" class="leancloud_visitors" data-flag-title="Immutable.js与React,Redux及reselect的实践">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-practice/bg.jpg" alt="效果图"></p>
<p>本篇文章将聚焦Immutable与Redux,reselect的项目实践，将从多方面阐述Immutable及Redux：包括什么是Immutable，为什么需要使用Immutable，Immutable.js与React，Redux及reselect的组合实践及优化，最后总结使用Immutable可能遇到的一些问题及解决方式。<br><a id="more"></a></p>
<h1 id="一、Immutable"><a href="#一、Immutable" class="headerlink" title="一、Immutable"></a>一、Immutable</h1><p>Immutable来自于函数式编程的世界，我们可以称它为不可变，试想如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> object = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</div><div class="line"><span class="keyword">var</span> object2 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</div><div class="line">object == object2<span class="comment">// false</span></div><div class="line">object === object2 <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>相等性检查将包括两个部分：</p>
<p>1.值检查<br>2.引用检查</p>
<h2 id="1-1-值检查"><a href="#1-1-值检查" class="headerlink" title="1.1 值检查"></a>1.1 值检查</h2><p>层层循环检查对象各属性值是否相同。</p>
<h2 id="1-2-引用检查"><a href="#1-2-引用检查" class="headerlink" title="1.2 引用检查"></a>1.2 引用检查</h2><p>JavaScript的对象是一个非常复杂的数据结构，它的键可以指向任意值，包括object。JavaScript创建的对象将存储在计算机内存中（对应一个物理地址），然后它返回一个引用，JavaScript引擎通过该引用可以访问该对象，该引用赋值给某个变量后，我们便可以通过该变量以引用的方式操作该对象。引用检查即检查两个对象的引用地址是否相同。</p>
<h2 id="1-3-React重新渲染"><a href="#1-3-React重新渲染" class="headerlink" title="1.3 React重新渲染"></a>1.3 React重新渲染</h2><p>React通过对组件属性（props）和状态（state）进行变更检查以决定是否更新并重新渲染该组件，若组件状态太过庞大，组件性能就会下降，因为对象越复杂，其相等性检查就会越慢。</p>
<p>1.对于嵌套对象，必须迭代层层进行检查判断，耗费时间过长；<br>2.若仅修改对象的属性，其引用保持不变，相等性检查中的引用检查结果不变；<br>Immutable提供一直简单快捷的方式以判断对象是否变更，对于React组件更新和重新渲染性能可以有较大帮助。</p>
<h1 id="二、Immutable数据"><a href="#二、Immutable数据" class="headerlink" title="二、Immutable数据"></a>二、Immutable数据</h1><p><em>Never mutated, instead copy it and then make change.</em><br><em>绝对不要突然修改对象，首先复制然后修改复制对象，再返回这个新对象，保持原对象不变。</em><br>Immutable对象和原生JavaScript对象的主要差异可以概括为以下两点：</p>
<p>1.持久化数据结构（Persistent data structures）<br>2.结构共享（Structures sharing Trie）</p>
<h2 id="2-1-持久化数据结构"><a href="#2-1-持久化数据结构" class="headerlink" title="2.1 持久化数据结构"></a>2.1 持久化数据结构</h2><p>持久数据结构主张所有操作都返回该数据结构的更新副本，并保持原有结构不变，而不是改变原来的结构。通常利用Trie构建它不可变的持久性数据结构，它的整体结构可以看作一棵树，一个树节点可以对应代表对象某一个属性，节点值即属性值。</p>
<h2 id="2-2-结构共享"><a href="#2-2-结构共享" class="headerlink" title="2.2 结构共享"></a>2.2 结构共享</h2><p>一旦创建一个Immutable Trie型对象，我们可以把该Trie型对象想象成如下一棵树，在之后的对象变更尽可能的重用树节点：</p>
<p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-practice/1.png" alt="效果图"></p>
<p>当我们要更新一个Immutable对象的属性值时，就是对应着需要重构该Trie树中的某一个节点，对于Trie树，我们修改某一节点只需要重构该节点及受其影响的节点，即其祖先节点，如上图中的四个绿色节点，而其他节点可以完全重用。</p>
<h2 id="2-3-参考"><a href="#2-3-参考" class="headerlink" title="2.3 参考"></a>2.3 参考</h2><p>1.<a href="https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2" target="_blank" rel="external">Immutable Persistent Data Structures</a><br>2.<a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="external">Trie</a></p>
<h1 id="三、为什么需要Immutable"><a href="#三、为什么需要Immutable" class="headerlink" title="三、为什么需要Immutable"></a>三、为什么需要Immutable</h1><p>上一节简单介绍了什么是Immutable，本节介绍为什么需要使用Immutable。</p>
<h2 id="3-1-不可变，副作用及突变"><a href="#3-1-不可变，副作用及突变" class="headerlink" title="3.1 不可变，副作用及突变"></a>3.1 不可变，副作用及突变</h2><p>我们不鼓励突然变更对象，因为那通常会打断时间旅行及bug相关调试，并且在react-redux的connect方法中状态突变将导致组件性能低下：</p>
<p>1.时间旅行：Redux DevTools开发工具期望应用在重新发起某个历史action时将仅仅返回一个状态值，而不改变任何东西，即无副作用。突变和异步操作将导致时间旅行混乱，行为不可预测。<br>2.react-redux：connect方法将检查mapStateToProps方法返回的props对象是否变更以决定是否需要更新组件。为了提高这个检查变更的性能，connect方法基于Immutabe状态对象进行改进，使用浅引用相等性检查来探测变更。这意味着对对象或数组的直接变更将无法被探测，导致组件无法更新。</p>
<p>在reducer函数中的诸如生成唯一ID或时间戳的其他副作用也会导致应用状态不可预测，难以调试和测试。</p>
<p>若Redux的某一reducer函数返回一个可以突变的状态对象，意味着我们不能追踪，预测状态，这可能导致组件发生多余的更新，重新渲染或者在需要更新时没有响应，也会导致难以跟踪调试bug。Immutable.js能提供一种Immutable方案解决如上提到的问题，同时其丰富的API也足够支撑我们复杂的开发。</p>
<h2 id="3-2-参考"><a href="#3-2-参考" class="headerlink" title="3.2 参考"></a>3.2 参考</h2><p>1.<a href="https://www.ibm.com/developerworks/java/library/j-jtp02183/index.html" target="_blank" rel="external">Why and When to use Immutable</a><br>2.<a href="https://stackoverflow.com/questions/3769607/why-do-we-need-immutable-class" target="_blank" rel="external">Why do we need Immutable class</a></p>
<h1 id="四、如何使用Immutable"><a href="#四、如何使用Immutable" class="headerlink" title="四、如何使用Immutable"></a>四、如何使用Immutable</h1><p>Immutable能给我们的应用提供较大的性能提升，但是我们必须正确的使用它，否则得不偿失。目前关于Immutable已经有一些类库，对于React应用，首选的是Immutable.js。</p>
<h2 id="4-1-Immutable-js与React"><a href="#4-1-Immutable-js与React" class="headerlink" title="4.1 Immutable.js与React"></a>4.1 Immutable.js与React</h2><p>首先需要明白的是React组件状态必须是一个原生JavaScript对象，而不能是一个Immutable对象，因为React的setState方法期望接受一个对象然后使用Object.assign方法将其与之前的状态对象合并。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Component</span>  <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    Constructor (props)  &#123;</div><div class="line">        <span class="keyword">super</span>(props)</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">data</span>: Immutable.Map(&#123;</div><div class="line">            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">            <span class="attr">todos</span>: List()</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.handleAddItemClick =       <span class="keyword">this</span>.handleAddItemClick.bind(<span class="keyword">this</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleAddItemClick () &#123;</div><div class="line">        <span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</div><div class="line">            <span class="attr">data</span>: data.update(<span class="string">'todos'</span>, todos =&gt; todos.push(data.get(<span class="string">'count'</span>)))</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render () &#123;</div><div class="line">        <span class="keyword">const</span> data = <span class="keyword">this</span>.state.data;</div><div class="line">        Return (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#123;this.handleAddItemClick&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">                    &#123;data.get('todos').map(item =&gt;</div><div class="line">                         <span class="tag">&lt;<span class="name">li</span>&gt;</span>Saved:</div><div class="line">                        &#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">                     )&#125;</div><div class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1.使用Immutable.js的访问API访问state，如get(),getIn();</p>
<p>2.使用Immutable.js的集合操作生成组件子元素：</p>
<p>使用高阶函数如map()，reduce()等创建React元素的子元素：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;data.get('todos').map(item =&gt;</div><div class="line">&lt;li&gt;Saved:</div><div class="line">&#123;item&#125;&lt;/li&gt;</div><div class="line">)&#125;</div></pre></td></tr></table></figure>
<p>3.使用Immutable.js的更新操作API更新state；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> (&#123;</div><div class="line">    <span class="attr">data</span>: data.update(<span class="string">'count'</span>, v =&gt; v + <span class="number">1</span>)</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> (&#123;</div><div class="line">    <span class="attr">data</span>: data.set(<span class="string">'count'</span>, data.get(<span class="string">'count'</span>) + <span class="number">1</span>)</div><div class="line">&#125;));</div></pre></td></tr></table></figure>
<p><strong>参考</strong><br>1.<a href="https://github.com/facebook/immutable-js/wiki/Immutable-as-React-state" target="_blank" rel="external">Immutable as React state</a></p>
<h2 id="4-2-Immutable-js与Pure-render"><a href="#4-2-Immutable-js与Pure-render" class="headerlink" title="4.2 Immutable.js与Pure render"></a>4.2 Immutable.js与Pure render</h2><p>shouldComponentUpdate方法作为React应用渲染性能优化最常见的一个优化点，默认的该方法总是返回true，意味着总是会执行组件render方法，进行Diff算法比较Virtual DOM，进而根据结果判断如何更新组件，有很多时候，如果明确不需要更新组件，我们可以直接在shouldComponentUpdate方法内返回false，可以极大提高性能。</p>
<h3 id="4-2-1-PURE-RENDER"><a href="#4-2-1-PURE-RENDER" class="headerlink" title="4.2.1 PURE RENDER"></a>4.2.1 PURE RENDER</h3><p>通常所说的Pure render即是重写shouldComponentUpdate方法，明确缩小更新组件的情况，同时尽量保证该方法的性能，权衡达到较大性能提升，如下，该方式通过浅比较两次props对象和state对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> !shallowEqual(<span class="keyword">this</span>.props, nextProps) || !shallowEqual(<span class="keyword">this</span>.state, nextState);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>shallowEqual浅比较如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">objA, objB</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (objA === objB) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> objA !== <span class="string">'object'</span> || objA === <span class="literal">null</span> ||</div><div class="line">      <span class="keyword">typeof</span> objB !== <span class="string">'object'</span> || objB === <span class="literal">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> keysA = <span class="built_in">Object</span>.keys(objA);</div><div class="line">  <span class="keyword">var</span> keysB = <span class="built_in">Object</span>.keys(objB);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Test for A's keys different from B.</span></div><div class="line">  <span class="keyword">var</span> bHasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty.bind(objB);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</div><div class="line">    <span class="keyword">if</span> (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先进行引用检查，若引用检查通过，则不需要继续检查，直接返回true；否则，进行类型判断，属性长度判断，不相等则直接返回false；最后遍历比较目标对象属性，并将其值与比较源对象的该属性值进行相等性检查（引用检查，值检查），不迭代对象，返回检查结果。</p>
<p>当然你也可以在shouldComponentUpdate方法内使用深比较，循环遍历对象比较，但是深比较很费性能，不建议使用。</p>
<h3 id="4-2-2-IMMUTABLE-JS与SHOULDCOMPONENTUPDATE"><a href="#4-2-2-IMMUTABLE-JS与SHOULDCOMPONENTUPDATE" class="headerlink" title="4.2.2 IMMUTABLE.JS与SHOULDCOMPONENTUPDATE"></a>4.2.2 IMMUTABLE.JS与SHOULDCOMPONENTUPDATE</h3><p>Immutable 提供了简洁高效的数据变更检查变方法，只需 === 和 is 比较就可以知道是否需要更新组件，而且这个检查操作成本极低，可以极大提高性能。使用Immutable.js修改 shouldComponentUpdate 如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; is &#125; <span class="keyword">from</span> <span class="string">'immutable'</span>;</div><div class="line"></div><div class="line">shouldComponentUpdate: <span class="function">(<span class="params">nextProps = &#123;&#125;, nextState = &#123;&#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> props = <span class="keyword">this</span>.props || &#123;&#125;, state = <span class="keyword">this</span>.state || &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(props).length !== <span class="built_in">Object</span>.keys(nextProps).length ||</div><div class="line">      <span class="built_in">Object</span>.keys(state).length !== <span class="built_in">Object</span>.keys(nextState).length) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextProps) &#123;</div><div class="line">    <span class="keyword">if</span> (!is(props[key], nextProps[key])) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> nextState) &#123;</div><div class="line">    <span class="keyword">if</span> (state[key] !== nextState[key] || !is(state[key], nextState[key])) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先进行属性长度比较，然后分别浅遍历props和state对象，然后对同名属性值进行===和is两种方式比较，若任何一种比较方式返回false，则表明组件有变更，则shouldComponentUpdate方法返回true，否则返回false。</p>
<h2 id="4-3-Immutable-js和Redux"><a href="#4-3-Immutable-js和Redux" class="headerlink" title="4.3 Immutable.js和Redux"></a>4.3 Immutable.js和Redux</h2><p>React本身是专注于视图层的一个JavaScript类库，所以其单独使用时状态一般不会过于复杂，所以其和Immutable.js的协作比较简单，更重要也是我们需要更多关注的地方是其与React应用状态管理容器的协作，下文就Immutable.js如何高效的与Redux协作进行阐述。</p>
<p>我们在Redux中讲状态（state）主要是指应用状态，而不是组件状态。</p>
<h3 id="4-3-1-REDUX-IMMUTABLE"><a href="#4-3-1-REDUX-IMMUTABLE" class="headerlink" title="4.3.1 REDUX-IMMUTABLE"></a>4.3.1 REDUX-IMMUTABLE</h3><p>原始Redux的combineReducers方法期望接受原生JavaScript对象并且它把state作为原生对象处理，所以当我们使用createStore方法并且接受一个Immutable对象作应用初始状态时，reducer将会返回一个错误，源代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if   (!isPlainObject(inputState)) &#123;</div><div class="line">    return   (                              </div><div class="line">        `The   $&#123;argumentName&#125; has unexpected type of "` +                                    (&#123;&#125;).toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] +</div><div class="line">      ".Expected argument to be an object with the following + </div><div class="line">      `keys:"$&#123;reducerKeys.join('", "')&#125;"`   </div><div class="line">    )  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上表明，原始类型reducer接受的state参数应该是一个原生JavaScript对象，我们需要对combineReducers其进行增强，以使其能处理Immutable对象，redux-immutable 即是用来创建一个可以和Immutable.js协作的Redux combineReducers。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> StateRecord = Immutable.Record(&#123;</div><div class="line">    <span class="attr">foo</span>: <span class="string">'bar'</span></div><div class="line"> &#125;);</div><div class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</div><div class="line">  <span class="attr">first</span>: firstReducer</div><div class="line">&#125;, StateRecord);</div></pre></td></tr></table></figure>
<h4 id="4-3-1-1-react-router-redux"><a href="#4-3-1-1-react-router-redux" class="headerlink" title="4.3.1.1 react-router-redux"></a>4.3.1.1 react-router-redux</h4><p>如果在项目中使用了react-router-redux类库，那么我们需要知道routeReducer不能处理Immutable，我们需要自定义一个新的reducer：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Immutable <span class="keyword">from</span> <span class="string">'immutable'</span>;</div><div class="line"><span class="keyword">import</span> &#123; LOCATION_CHANGE &#125; <span class="keyword">from</span> <span class="string">'react-router-redux'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> initialState = Immutable.fromJS(&#123;</div><div class="line">   <span class="attr">locationBeforeTransitions</span>: <span class="literal">null</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = initialState, action) =&gt; &#123;</div><div class="line">   <span class="keyword">if</span> (action.type === LOCATION_CHANGE) &#123;</div><div class="line">     <span class="keyword">return</span> state.set(<span class="string">'locationBeforeTransitions'</span>, action.payload);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> state;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>当我们使用syncHistoryWithStore方法连接history对象和store时，需要将routing负载转换成一个JavaScript对象，如下传递一个selectLocationState参数给syncHistoryWithStore方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"><span class="keyword">import</span> &#123; syncHistoryWithStore &#125; <span class="keyword">from</span> <span class="string">'react-router-redux'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> history = syncHistoryWithStore(browserHistory, store, &#123;</div><div class="line">   selectLocationState (state) &#123;</div><div class="line">       <span class="keyword">return</span> state.get(<span class="string">'routing'</span>).toJS();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="4-3-2-IMMUTABLE-JS与REDUX实践"><a href="#4-3-2-IMMUTABLE-JS与REDUX实践" class="headerlink" title="4.3.2 IMMUTABLE.JS与REDUX实践"></a>4.3.2 IMMUTABLE.JS与REDUX实践</h3><p>当使用Immutable.js和Redux协作开发时，可以从如下几方面思考我们的实践。</p>
<h4 id="4-3-2-1-JavaScript对象转换为Immutable对象"><a href="#4-3-2-1-JavaScript对象转换为Immutable对象" class="headerlink" title="4.3.2.1 JavaScript对象转换为Immutable对象"></a>4.3.2.1 JavaScript对象转换为Immutable对象</h4><p>不要在Immutable对象中混用原生JavaScript对象；</p>
<p>当在Immutable对象内添加JavaScript对象时，首先使用fromJS()方法将JavaScript对象转换为Immutable对象，然后使用update(),merge(),set()等更新API对Immutable对象进行更新操作；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// avoid</span></div><div class="line"><span class="keyword">const</span> newObj = &#123; <span class="attr">key</span>: value &#125;</div><div class="line"><span class="keyword">const</span> newState = state.setIn([<span class="string">'prop1'</span>], newObj)</div><div class="line"><span class="comment">// newObj has been added as a plain JavaScript object, NOT as an Immutable.JS Map</span></div><div class="line"></div><div class="line"><span class="comment">// recommended</span></div><div class="line"><span class="keyword">const</span> newObj = &#123; <span class="attr">key</span>: value &#125;</div><div class="line"><span class="keyword">const</span> newState = state.setIn([<span class="string">'prop1'</span>], fromJS(newObj))</div></pre></td></tr></table></figure>
<h4 id="4-3-2-2-Immutable与Redux-state-tree"><a href="#4-3-2-2-Immutable与Redux-state-tree" class="headerlink" title="4.3.2.2 Immutable与Redux state tree"></a>4.3.2.2 Immutable与Redux state tree</h4><p>1.使用Immutable对象表示完整的Redux状态树；</p>
<p>对于一个Redux应用，完整的状态树应该由一个Immutable对象表示，而没有原生JavaScript对象。</p>
<p>2.使用fromJS()方法创建状态树</p>
<p>状态树对象可以是一个Immutable.Record或者任何其他的实现了get,set,withMutations方法的Immutable集合的实例。</p>
<p>3.使用redux-immutable库调整combineReducers方法使其能处理Immutable。</p>
<h4 id="4-3-2-3-Immutable与Redux组件"><a href="#4-3-2-3-Immutable与Redux组件" class="headerlink" title="4.3.2.3 Immutable与Redux组件"></a>4.3.2.3 Immutable与Redux组件</h4><p>当使用Redux作React应用状态管理容器时，我们通常将组件分为容器组件和展示型组件，Immutable与Redux组件的实践也主要围绕这两者。</p>
<p>1.除了在展示型组件内，其他地方一律使用Immutable方式操作状态对象；</p>
<p>为了保证应用性能，在容器组件，选择器（selectors），reducer函数，action创建函数，sagas和thunks函数内等所有地方均使用Immutable，但是不在展示型组件内使用。</p>
<p>2.在容器组件内使用Immutable</p>
<p>容器组件可以使用react-redux提供的connect方法访问redux的store，所以我们需要保证选择器（selectors）总是返回Immutable对象，否则，将会导致不必要的重新渲染。另外，我们可以使用诸如reselect的第三方库缓存选择器（selectors）以提高部分情景下的性能。</p>
<h4 id="4-3-2-4-Immutable对象转换为JavaScript对象"><a href="#4-3-2-4-Immutable对象转换为JavaScript对象" class="headerlink" title="4.3.2.4 Immutable对象转换为JavaScript对象"></a>4.3.2.4 Immutable对象转换为JavaScript对象</h4><p>toJS()方法功能就是把一个Immutable对象转换为一个JavaScript对象，而我们通常尽可能将Immutable对象转换为JavaScript对象这一操作放在容器组件中，这也与容器组件的宗旨吻合。另外toJS方法性能极低，应该尽量限制该方法的使用，如在mapStateToProps方法和展示型组件内。</p>
<p>1.绝对不要在mapStateToProps方法内使用toJS()方法</p>
<p>toJS()方法每次会调用时都是返回一个原生JavaScript对象，如果在mapStateToProps方法内使用toJS()方法，则每次状态树（Immutable对象）变更时，无论该toJS()方法返回的JavaScript对象是否实际发生改变，组件都会认为该对象发生变更，从而导致不必要的重新渲染。</p>
<p>2.绝对不要在展示型组件内使用toJS()方法</p>
<p>如果传递给某组件一个Immuatble对象类型的prop，则该组件的渲染取决于该Immutable对象，这将给组件的重用，测试和重构带来更多困难。</p>
<p>3.当容器组件将Immutable类型的属性（props）传入展示型组件时，需使用高阶组件（HOC）将其转换为原生JavaScript对象。</p>
<p>该高阶组件定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> &#123; Iterable &#125; <span class="keyword">from</span> <span class="string">'immutable'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> toJS = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> wrappedComponentProps =&gt; &#123;</div><div class="line"><span class="keyword">const</span> KEY = <span class="number">0</span></div><div class="line">   <span class="keyword">const</span> VALUE = <span class="number">1</span></div><div class="line"><span class="keyword">const</span> propsJS = <span class="built_in">Object</span>.entries(wrappedComponentProps)</div><div class="line">   .reduce(<span class="function">(<span class="params">newProps, wrappedComponentProp</span>) =&gt;</span> &#123;</div><div class="line">    newProps[wrappedComponentProp[KEY]] =   Iterable.isIterable(wrappedComponentProp[VALUE]) ? wrappedComponentProp[VALUE].toJS() : wrappedComponentProp[VALUE]</div><div class="line">        <span class="keyword">return</span> newProps</div><div class="line">&#125;, &#123;&#125;)</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...propsJS</span>&#125; /&gt;</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该高阶组件内，首先使用Object.entries方法遍历传入组件的props，然后使用toJS()方法将该组件内Immutable类型的prop转换为JavaScript对象，该高阶组件通常可以在容器组件内使用，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></div><div class="line"><span class="keyword">import</span> &#123; toJS &#125; <span class="keyword">from</span> <span class="string">'./to-js'</span></div><div class="line"><span class="keyword">import</span> DumbComponent <span class="keyword">from</span> <span class="string">'./dumb.component'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</div><div class="line"><span class="keyword">return</span> &#123;</div><div class="line">     <span class="comment">// obj is an Immutable object in Smart Component, but it’s converted to a plain</span></div><div class="line">     <span class="comment">// JavaScript object by toJS, and so passed to DumbComponent as a pure JavaScript</span></div><div class="line">     <span class="comment">// object. Because it’s still an Immutable.JS object here in mapStateToProps, though,</span></div><div class="line">     <span class="comment">// there is no issue with errant re-renderings.</span></div><div class="line">    obj:getImmutableObjectFromStateTree(state)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(toJS(DumbComponent))</div></pre></td></tr></table></figure>
<p>这类高阶组件不会造成过多的性能下降，因为高阶组件只在被连接组件（通常即展示型组件）属性变更时才会被再次调用。你也许会问既然在高阶组件内使用toJS()方法必然会造成一定的性能下降，为什么不在展示型组件内也保持使用Immutable对象呢？事实上，相对于高阶组件内使用toJS()方法的这一点性能损失而言，避免Immutable渗透入展示型组件带来的可维护性，可重用性及可测试性是我们更应该看重的。</p>
<h4 id="4-3-2-5-参考"><a href="#4-3-2-5-参考" class="headerlink" title="4.3.2.5 参考"></a>4.3.2.5 参考</h4><p>1.<a href="http://redux.js.org/docs/recipes/UsingImmutableJS.html#immutable-js-best-practices" target="_blank" rel="external">Immutable.js Best practices</a></p>
<h2 id="4-4-Immutable-js与reselect"><a href="#4-4-Immutable-js与reselect" class="headerlink" title="4.4 Immutable.js与reselect"></a>4.4 Immutable.js与reselect</h2><h3 id="4-4-1-RESELECT"><a href="#4-4-1-RESELECT" class="headerlink" title="4.4.1 RESELECT"></a>4.4.1 RESELECT</h3><p>使用Redux管理React应用状态时，mapStateToProps方法作为从Redux Store上获取数据过程中的重要一环，它一定不能有性能缺陷，它本身是一个函数，通过计算返回一个对象，这个计算过程通常是基于Redux Store状态树进行的，而很明显的Redux状态树越复杂，这个计算过程可能就越耗时，我们应该要能够尽可能减少这个计算过程，比如重复在相同状态下渲染组件，多次的计算过程显然是多余的，我们是否可以缓存该结果呢？这个问题的解决者就是reselect，它可以提高应用获取数据的性能。</p>
<p><em>reselect的原理是，只要相关状态不变，即直接使用上一次的缓存结果。</em></p>
<h3 id="4-4-2-选择器"><a href="#4-4-2-选择器" class="headerlink" title="4.4.2 选择器"></a>4.4.2 选择器</h3><p>reselect通过创建选择器（selectors），该函数接受一个state参数，然后返回我们需要在mapStateToProps方法内返回对象的某一个数据项，一个选择器的处理可以分为两个步骤：</p>
<p>1.接受state参数，根据我们提供的映射函数数组分别进行计算，如果返回结果和上次第一步的计算结果一致，说明命中缓存，则不进行第二步计算，直接返回上次第二步的计算结果，否则继续第二步计算。第一步的结果比较，通常仅仅是===相等性检查，性能是足够的。</p>
<p>2.根据第一步返回的结果，计算，返回最终结果。</p>
<p>以TODO为例，有如下选择器函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; createSelector &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"><span class="keyword">import</span> &#123; FilterTypes &#125; <span class="keyword">from</span> <span class="string">'../constants'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> selectFilterTodos = createSelector(</div><div class="line">[getTodos, getFilters],</div><div class="line">(todos, filters) =&gt; &#123;</div><div class="line">     <span class="keyword">switch</span>(filters) &#123;</div><div class="line">       <span class="keyword">case</span> FilterTypes.ALL:</div><div class="line">        <span class="keyword">return</span> todos;</div><div class="line">       <span class="keyword">case</span> FilterTypes.COMPLETED:</div><div class="line">        <span class="keyword">return</span> todos.filter(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.completed)</div><div class="line">       <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> todos</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>如上，createSelector方法，接受两个参数：</p>
<p>1.第一个参数是一个映射函数数组，选择器处理流程的第一步所处理的数据即为该数组内各函数的返回值，这些返回值也依次作为参数传入第二步处理函数；</p>
<p>2.第二个参数则是，第二步的具体计算函数，也即缓存结果处理函数，其返回结果也即mapStateToProps方法所需的数据；</p>
<p>然后在mapStateToProps内使用该选择器函数，接受state参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line"> <span class="keyword">return</span> &#123;</div><div class="line">   <span class="attr">todos</span>: selectFilterTodos(state)</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上文中的映射函数，内容如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;state.todos&#125;</div><div class="line"><span class="keyword">const</span> getFilter = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;state.filter&#125;</div></pre></td></tr></table></figure>
<h4 id="4-4-2-1-Immutable概念数据"><a href="#4-4-2-1-Immutable概念数据" class="headerlink" title="4.4.2.1 Immutable概念数据"></a>4.4.2.1 Immutable概念数据</h4><p>另外需要注意的是，传入createSelector的映射函数返回的状态应该是不可变的，因为默认缓存命中检测函数使用引用检查，如果使用JavaScript对象，仅改变该对象的某一属性，引用检测是无法检测到属性变更的，这将导致组件无法响应更新。在缓存结果处理函数内执行如下代码，是不行的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &#123;</div><div class="line">  todo.completed = !areAllMarked</div><div class="line">  <span class="keyword">return</span> todo</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这种突然性的改变某一状态对象后，其差异检测无法通过，将命中缓存，无法更新，在未使用Immutable.js库时，应该采用如下这种方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, todo, &#123;</div><div class="line">  <span class="attr">completed</span>: !areAllMarked</div><div class="line">&#125;))</div></pre></td></tr></table></figure></p>
<p>总是返回一个新对象，而不影响原对象。</p>
<h3 id="4-4-3-自定义选择器"><a href="#4-4-3-自定义选择器" class="headerlink" title="4.4.3 自定义选择器"></a>4.4.3 自定义选择器</h3><p>前面使用createSelector方法创建的选择器函数默认缓存间隔是1，只缓存上一次的计算结果，即选择器处理流程的第一步，仅会将当前计算结果与紧邻的上一次计算结果对比。</p>
<p>有时候也许我们会想是否可以加大缓存程度呢？比如当前状态a，变化到状态b，此时缓存的仅仅是状态b下的选择器计算结果，如果状态再次变为a，比对结果自然是false，依然会执行复杂的计算过程，那我们是否能缓存第一次状态a下的选择器计算结果呢？答案就在createSelectorCreator。</p>
<h4 id="4-4-3-1-defaultMemoize"><a href="#4-4-3-1-defaultMemoize" class="headerlink" title="4.4.3.1 defaultMemoize"></a>4.4.3.1 defaultMemoize</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaultMemoize(func, equalityCheck = defaultEqualityCheck)</div></pre></td></tr></table></figure>
<p>defaultMemoize将缓存传递的第一个函数参数func的返回结果，该函数是使用createSelector创建选择器时传入的缓存结果处理函数，其默认缓存度为1。</p>
<p>equalityCheck是创建的选择器使用的缓存命中检测函数，默认函数代码如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultEqualityCheck</span>(<span class="params">currentVal, previousVal</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> currentVal === previousVal</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只是简单的进行引用检查。</p>
<h4 id="4-4-3-2-createSelectorCreator"><a href="#4-4-3-2-createSelectorCreator" class="headerlink" title="4.4.3.2 createSelectorCreator"></a>4.4.3.2 createSelectorCreator</h4><p>createSelectorCreator方法支持我们创建一个自定义的createSelector函数，并且支持我们传入自定义的缓存计算函数，覆盖默认的defaultMemoize函数，定义格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">createSelectorCreator(memoize, ...memoizeOptions)</div></pre></td></tr></table></figure>
<p>1.memoize参数是一个缓存函数，用以替代defaultMemoize，该函数接受的第一个参数就是创建选择器时传入的缓存结果处理函数;<br>2.…memoizeOptions是0或多个配置对象，将传递给memoize缓存函数作为后续参数，如可以传递一个自定义缓存检测函数覆盖defaultEqualityCheck;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用lodash.isEqual覆盖默认的‘===’引用等值检测</span></div><div class="line"><span class="keyword">import</span> isEqual <span class="keyword">from</span> <span class="string">'lodash.isEqual'</span></div><div class="line"><span class="keyword">import</span> &#123; createSelectorCreator, defaultMemoize &#125; <span class="keyword">from</span> <span class="string">'reselect'</span></div><div class="line"></div><div class="line"><span class="comment">// 自定义选择器创建函数</span></div><div class="line"><span class="keyword">const</span> customSelectorCreator = createSelectorCreator(</div><div class="line">  customMemoize, <span class="comment">// 自定义缓存函数，也可以直接使用defaultMemoize</span></div><div class="line">  isEqual, <span class="comment">// 配置项</span></div><div class="line">  option2 <span class="comment">// 配置项</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 自定义选择器</span></div><div class="line"><span class="keyword">const</span> customSelector = customSelectorCreator(</div><div class="line">  input1, <span class="comment">// 映射函数</span></div><div class="line">  input2, <span class="comment">// 映射函数</span></div><div class="line">  resultFunc <span class="comment">// 缓存结果处理函数</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// 调用选择器</span></div><div class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</div><div class="line">  <span class="attr">todos</span>: customSelector(state)   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在自定义选择器函数内部，会执行缓存函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">customMemoize(resultFunc, isEqual, option2)</div></pre></td></tr></table></figure></p>
<h3 id="4-4-4-结合IMMUTABLE-JS"><a href="#4-4-4-结合IMMUTABLE-JS" class="headerlink" title="4.4.4 结合IMMUTABLE.JS"></a>4.4.4 结合IMMUTABLE.JS</h3><p>如上文为例，reselect是内在需要使用Immutable概念数据的，当我们把整个Redux状态树Immutable化以后，需要进行一些修改。</p>
<p>修改映射函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> getTodos = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;state.get(<span class="string">'todos'</span>)&#125;</div><div class="line"><span class="keyword">const</span> getFilter = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;state.get(<span class="string">'filter'</span>)&#125;</div></pre></td></tr></table></figure></p>
<p>特别需要注意的是在选择器第二步处理函数内，如果涉及Immutable操作，也需要额外修改成Immutable对应方式。</p>
<h1 id="五、Immutable实践中的问题"><a href="#五、Immutable实践中的问题" class="headerlink" title="五、Immutable实践中的问题"></a>五、Immutable实践中的问题</h1><p>无论什么情况，都不存在绝对完美的事物或者技术，使用Immutable.js也必然会带来一些问题，我们能做的则是尽量避免或者尽最大可能的分化这些问题，而可以更多的去发扬该技术带来的优势，使用Immutable.js最常见的问题如下。</p>
<p>1.很难进行内部协作</p>
<p>Immutable对象和JavaScript对象之间存在的巨大差异，使得两者之间的协作通常较麻烦，而这也正是许多问题的源头。</p>
<p>（1）使用Immutable.js后我们不再能使用点号和中括号的方式访问对象属性，而只能使用其提供的get,getIn等API方式；<br>（2）不再能使用ES6提供的解构和展开操作符；<br>（3）和第三方库协作困难，如lodash和JQuery等。<br>2.渗透整个代码库</p>
<p>Immutable代码将渗透入整个项目，这种对于外部类库的强依赖会给项目的后期带来很大约束，之后如果想移除或者替换Immutable是很困难的。</p>
<p>3.不适合经常变更的简单状态对象</p>
<p>Immutable和复杂的数据使用时有很大的性能提升，但是对于简单的经常变更的数据，它的表现并不好。</p>
<p>4.切断对象引用将导致性能低下</p>
<p>Immutable最大的优势是它的浅比较可以极大提高性能，当我们多次使用toJS方法时，尽管对象实际没有变更，但是它们之间的等值检查不能通过，将导致重新渲染。更重要的是如果我们在mapStateToProps方法内使用toJS将极大破坏组件性能，如果真的需要，我们应该使用前面介绍的高阶组件方式转换。</p>
<p>5.难以调试</p>
<p>当我们审查一个Immutable对象时，浏览器会打印出Immutable.js的整个嵌套结构，而我们实际需要的只是其中小一部分，这导致我们调试较困难，可以使用Immutable.js Object Formatter浏览器插件解决。</p>
<p>本文引用自 <a href="http://blog.codingplayboy.com/2017/09/14/immutable-react-redux/" target="_blank" rel="external">http://blog.codingplayboy.com/2017/09/14/immutable-react-redux/</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/react-redux-Immutable-reselect/" rel="tag"># --react redux Immutable reselect</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/19/Immutable-react/" rel="next" title="Immutable 详解及 React 中实践">
                <i class="fa fa-chevron-left"></i> Immutable 详解及 React 中实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/21/react-HOC/" rel="prev" title="深入浅出React高阶组件">
                深入浅出React高阶组件 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Jacob" />
          <p class="site-author-name" itemprop="name">Jacob</p>
           
              <p class="site-description motion-element" itemprop="description">记录生活点滴</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/your-user-name" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/your-user-name" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/your-user-name" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、Immutable"><span class="nav-text">一、Immutable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-值检查"><span class="nav-text">1.1 值检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-引用检查"><span class="nav-text">1.2 引用检查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-React重新渲染"><span class="nav-text">1.3 React重新渲染</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、Immutable数据"><span class="nav-text">二、Immutable数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-持久化数据结构"><span class="nav-text">2.1 持久化数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-结构共享"><span class="nav-text">2.2 结构共享</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-参考"><span class="nav-text">2.3 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、为什么需要Immutable"><span class="nav-text">三、为什么需要Immutable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-不可变，副作用及突变"><span class="nav-text">3.1 不可变，副作用及突变</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-参考"><span class="nav-text">3.2 参考</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、如何使用Immutable"><span class="nav-text">四、如何使用Immutable</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Immutable-js与React"><span class="nav-text">4.1 Immutable.js与React</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Immutable-js与Pure-render"><span class="nav-text">4.2 Immutable.js与Pure render</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-PURE-RENDER"><span class="nav-text">4.2.1 PURE RENDER</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-IMMUTABLE-JS与SHOULDCOMPONENTUPDATE"><span class="nav-text">4.2.2 IMMUTABLE.JS与SHOULDCOMPONENTUPDATE</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-Immutable-js和Redux"><span class="nav-text">4.3 Immutable.js和Redux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-REDUX-IMMUTABLE"><span class="nav-text">4.3.1 REDUX-IMMUTABLE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-1-react-router-redux"><span class="nav-text">4.3.1.1 react-router-redux</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-IMMUTABLE-JS与REDUX实践"><span class="nav-text">4.3.2 IMMUTABLE.JS与REDUX实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-1-JavaScript对象转换为Immutable对象"><span class="nav-text">4.3.2.1 JavaScript对象转换为Immutable对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-2-Immutable与Redux-state-tree"><span class="nav-text">4.3.2.2 Immutable与Redux state tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-3-Immutable与Redux组件"><span class="nav-text">4.3.2.3 Immutable与Redux组件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-4-Immutable对象转换为JavaScript对象"><span class="nav-text">4.3.2.4 Immutable对象转换为JavaScript对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-5-参考"><span class="nav-text">4.3.2.5 参考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-Immutable-js与reselect"><span class="nav-text">4.4 Immutable.js与reselect</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-RESELECT"><span class="nav-text">4.4.1 RESELECT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-选择器"><span class="nav-text">4.4.2 选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-1-Immutable概念数据"><span class="nav-text">4.4.2.1 Immutable概念数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-自定义选择器"><span class="nav-text">4.4.3 自定义选择器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-1-defaultMemoize"><span class="nav-text">4.4.3.1 defaultMemoize</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-2-createSelectorCreator"><span class="nav-text">4.4.3.2 createSelectorCreator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-4-结合IMMUTABLE-JS"><span class="nav-text">4.4.4 结合IMMUTABLE.JS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、Immutable实践中的问题"><span class="nav-text">五、Immutable实践中的问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jacob</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://ZheningLin.github.io/2019/02/20/react-practice/';
          this.page.identifier = '2019/02/20/react-practice/';
          this.page.title = 'Immutable.js与React,Redux及reselect的实践';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("p66dtkiI4ISfwBtjQrYYOuGg-gzGzoHsz", "5gyWux8Xrw1X9920CkoKBueE");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
