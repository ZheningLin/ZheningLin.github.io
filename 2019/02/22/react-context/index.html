<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="--react  context," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一、前言Context被翻译为上下文，在编程领域，这是一个经常会接触到的概念，React中也有。 在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。">
<meta name="keywords" content="--react  context">
<meta property="og:type" content="article">
<meta property="og:title" content="对 React Context 的理解以及应用">
<meta property="og:url" content="http://ZheningLin.github.io/2019/02/22/react-context/index.html">
<meta property="og:site_name" content="Jacob&#39;s Notes">
<meta property="og:description" content="一、前言Context被翻译为上下文，在编程领域，这是一个经常会接触到的概念，React中也有。 在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/bg.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/2.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/3.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/4.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/5.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/6.png">
<meta property="og:updated_time" content="2019-02-22T07:47:33.753Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="对 React Context 的理解以及应用">
<meta name="twitter:description" content="一、前言Context被翻译为上下文，在编程领域，这是一个经常会接触到的概念，React中也有。 在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/bg.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '7TPGXTD83V',
      apiKey: '3c064d4a40968fd9c426dab1bb9ed2ab',
      indexName: 'test',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ZheningLin.github.io/2019/02/22/react-context/"/>





  <title>对 React Context 的理解以及应用 | Jacob's Notes</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d8e4fd1e3f6fbb2379d52ea3f14d4e13";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jacob's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Quick notes</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ZheningLin.github.io/2019/02/22/react-context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jacob">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jacob's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">对 React Context 的理解以及应用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T15:03:26+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/日志-二级目录/" itemprop="url" rel="index">
                    <span itemprop="name">-日志 -二级目录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/22/react-context/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/02/22/react-context/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/02/22/react-context/" class="leancloud_visitors" data-flag-title="对 React Context 的理解以及应用">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/bg.jpg" alt="效果图"></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Context被翻译为上下文，在编程领域，这是一个经常会接触到的概念，React中也有。</p>
<p>在React的官方文档中，Context被归类为高级部分(Advanced)，属于React的高级API，但官方并不建议在稳定版的App中使用Context。<br><a id="more"></a></p>
<blockquote>
<p>The vast majority of applications do not need to use content.<br>If you want your application to be stable, don’t use context. It is an experimental API and it is likely to break in future releases of React.</p>
</blockquote>
<p>不过，这并非意味着我们不需要关注Context。事实上，很多优秀的React组件都通过Context来完成自己的功能，比如react-redux的<provider>，就是通过Context提供一个全局态的store，拖拽组件react-dnd，通过Context在组件中分发DOM的Drag和Drop事件，路由组件react-router通过Context管理路由状态等等。在React组件开发中，如果用好Context，可以让你的组件变得强大，而且灵活。<br>今天就想跟大家聊一聊，我在开发当中，所认识到的这个Context，以及我是如何使用它来进行组件开发的。</provider></p>
<blockquote>
<p>注：本文中所有提到的App皆指Web端App。</p>
</blockquote>
<h1 id="二、初识React-Context"><a href="#二、初识React-Context" class="headerlink" title="二、初识React Context"></a>二、初识React Context</h1><h2 id="2-1-官方对于Context的定义"><a href="#2-1-官方对于Context的定义" class="headerlink" title="2.1 官方对于Context的定义"></a>2.1 官方对于Context的定义</h2><p>React文档官网并未对Context给出“是什么”的定义，更多是描述使用的Context的场景，以及如何使用Context。<br>官网对于使用Context的场景是这样描述的：</p>
<blockquote>
<p>In Some Cases, you want to pass data through the component tree without having to pass the props down manuallys at every level. you can do this directly in React with the powerful “context” API.</p>
</blockquote>
<p>简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。</p>
<p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/1.png" alt="效果图"></p>
<p>使用props或者state传递数据，数据自顶下流。</p>
<p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/2.png" alt="效果图"></p>
<p>使用Context，可以跨越组件进行数据传递。</p>
<h2 id="2-2-如何使用Context"><a href="#2-2-如何使用Context" class="headerlink" title="2.2 如何使用Context"></a>2.2 如何使用Context</h2><p>如果要Context发挥作用，需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。<br>对于父组件，也就是Context生产者，需要通过一个静态属性childContextTypes声明提供给子组件的Context对象的属性，并实现一个实例getChildContext方法，返回一个代表Context的纯对象 (plain object) 。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MiddleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class ParentComponent extends React.Component &#123;</div><div class="line">  // 声明Context对象属性</div><div class="line">  static childContextTypes = &#123;</div><div class="line">    propA: PropTypes.string,</div><div class="line">    methodA: PropTypes.func</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  // 返回Context对象，方法名是约定好的</div><div class="line">  getChildContext () &#123;</div><div class="line">    return &#123;</div><div class="line">      propA: 'propA',</div><div class="line">      methodA: () =&gt; 'methodA'</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  render () &#123;</div><div class="line">    return <span class="tag">&lt;<span class="name">MiddleComponent</span> /&gt;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于Context的消费者，通过如下方式访问父组件提供的Context。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="comment">// 声明需要使用的Context属性</span></div><div class="line">  <span class="keyword">static</span> contextTypes = &#123;</div><div class="line">    <span class="attr">propA</span>: PropTypes.string</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">const</span> &#123;</div><div class="line">      propA,</div><div class="line">      methodA</div><div class="line">    &#125; = <span class="keyword">this</span>.context</div><div class="line">    </div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`context.propA = <span class="subst">$&#123;propA&#125;</span>`</span>)  <span class="comment">// context.propA = propA</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`context.methodA = <span class="subst">$&#123;methodA&#125;</span>`</span>)  <span class="comment">// context.methodA = undefined</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>子组件需要通过一个静态属性contextTypes声明后，才能访问父组件Context对象的属性，否则，即使属性名没写错，拿到的对象也是undefined。<br>对于无状态子组件(Stateless Component)，可以通过如下方式访问父组件的Context</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ChildComponent = <span class="function">(<span class="params">props, context</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> &#123;</div><div class="line">    propA</div><div class="line">  &#125; = context</div><div class="line">    </div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`context.propA = <span class="subst">$&#123;propA&#125;</span>`</span>)  <span class="comment">// context.propA = propA</span></div><div class="line">    </div><div class="line">  <span class="keyword">return</span> ...</div><div class="line">&#125;</div><div class="line">  </div><div class="line">ChildComponent.contextProps = &#123;</div><div class="line">  <span class="attr">propA</span>: PropTypes.string    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在接下来的发行版本中，React对Context的API做了调整，更加明确了生产者消费者模式的使用方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ThemeContext = React.createContext(&#123;</div><div class="line">  <span class="attr">background</span>: <span class="string">'red'</span>,</div><div class="line">  <span class="attr">color</span>: <span class="string">'white'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过静态方法React.createContext()创建一个Context对象，这个Context对象包含两个组件，<provider>和<consumer>。</consumer></provider></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;background:</span> '<span class="attr">green</span>', <span class="attr">color:</span> '<span class="attr">white</span>'&#125;&#125;&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><provider>的value相当于现在的getChildContext()。</provider></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Title</span>&gt;</span>Hello React Context API<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Title</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></div><div class="line">        &#123;context =&gt; (</div><div class="line">          <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;background:</span> <span class="attr">context.background</span>, <span class="attr">color:</span> <span class="attr">context.color</span>&#125;&#125;&gt;</span></div><div class="line">            &#123;this.props.children&#125;</div><div class="line">          <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">        )&#125;</div><div class="line">      <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><consumer>的children必须是一个函数，通过函数的参数获取<provider>提供的Context。</provider></consumer></p>
<p>可见，Context的新API更加贴近React的风格。</p>
<h2 id="3-3-几个可以直接获取Context的地方"><a href="#3-3-几个可以直接获取Context的地方" class="headerlink" title="3.3 几个可以直接获取Context的地方"></a>3.3 几个可以直接获取Context的地方</h2><p>实际上，除了实例的context属性(this.context)，React组件还有很多个地方可以直接访问父组件提供的Context。比如构造方法：</p>
<ul>
<li>constructor(props, context)</li>
</ul>
<p>比如生命周期：</p>
<ul>
<li>componentWillReceiveProps(nextProps, nextContext)</li>
<li>shouldComponentUpdate(nextProps, nextState, nextContext)</li>
<li>componetWillUpdate(nextProps, nextState, nextContext)</li>
</ul>
<p>对于面向函数的无状态组件，可以通过函数的参数直接访问组件的Context。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> StatelessComponent = <span class="function">(<span class="params">props, context</span>) =&gt;</span> (</div><div class="line">  ......</div><div class="line">)</div></pre></td></tr></table></figure>
<p>以上是Context的基础，更具体的指南内容可参见<a href="https://reactjs.org/docs/context.html" target="_blank" rel="external">这里</a></p>
<h1 id="三、我对Context的理解"><a href="#三、我对Context的理解" class="headerlink" title="三、我对Context的理解"></a>三、我对Context的理解</h1><p>OK，说完基础的东西，现在聊一聊我对React的Context的理解。</p>
<h2 id="3-1-把Context当做组件作用域"><a href="#3-1-把Context当做组件作用域" class="headerlink" title="3.1 把Context当做组件作用域"></a>3.1 把Context当做组件作用域</h2><p>使用React的开发者都知道，一个React App本质就是一棵React组件树，每个React组件相当于这棵树上的一个节点，除了App的根节点，其他每个节点都存在一条父组件链。</p>
<p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/3.png" alt="效果图"></p>
<p>例如上图，<child>的父组件链是<subnode> – <node> – <app>，<subnode>的父组件链是<node> – <app>，<node>的父组件链只有一个组件节点，就是<app>。<br>这些以树状连接的组件节点，实际上也组成了一棵Context树，每个节点的Context，来自父组件链上所有组件节点通过getChildContext()所提供的Context对象组合而成的对象。</app></node></app></node></subnode></app></node></subnode></child></p>
<p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/4.png" alt="效果图"></p>
<p>有了解JS作用域链概念的开发者应该都知道，JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。<br>假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而Context对象的属性可以看成作用域上的活动对象。由于组件的Context由其父节点链上所有组件通过getChildContext()返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。<br>所以，我借鉴了JS作用域链的思路，把Context当成是组件的作用域来使用。</p>
<h2 id="3-2-关注Context的可控性和影响范围"><a href="#3-2-关注Context的可控性和影响范围" class="headerlink" title="3.2 关注Context的可控性和影响范围"></a>3.2 关注Context的可控性和影响范围</h2><p>不过，作为组件作用域来看待的Context与常见的作用域的概念 (就我个人目前接触到的编程语言而言) 是有所区别的。我们需要关注Context的可控性和影响范围。<br>在我们平时的开发中，用到作用域或者上下文的场景是很常见，很自然，甚至是无感知的，然而，在React中使用Context并不是那么容易。父组件提供Context需要通过childContextTypes进行“声明”，子组件使用父组件的Context属性需要通过contextTypes进行“申请”，所以，我认为React的Context是一种<strong>“带权限”的组件作用域</strong>。<br>这种“带权限”的方式有何好处？就我个人的理解，首先是保持框架API的一致性，和propTypes一样，使用声明式编码风格。另外就是，可以在一定程度上确保组件所提供的Context的可控性和影响范围。<br>React App的组件是树状结构，一层一层延伸，父子组件是一对多的线性依赖。随意的使用Context其实会破坏这种依赖关系，导致组件之间一些不必要的额外依赖，降低组件的复用性，进而可能会影响到App的可维护性。</p>
<p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/5.png" alt="效果图"></p>
<p>通过上图可以看到，原本线性依赖的组件树，由于子组件使用了父组件的Context，导致<child>组件对<node>和<app>都产生了依赖关系。一旦脱离了这两个组件，<child>的可用性就无法保障了，减低了<child>的复用性。</child></child></app></node></child></p>
<p><img src="https://raw.githubusercontent.com/ZheningLin/ZheningLin.github.io/master/images/react-context/6.png" alt="效果图"></p>
<p>在我看来，通过Context暴露数据或者API不是一种优雅的实践方案，尽管react-redux是这么干的。因此需要一种机制，或者说约束，去降低不必要的影响。<br>通过childContextTypes和contextTypes这两个静态属性的约束，可以在一定程度保障，只有组件自身，或者是与组件相关的其他子组件才可以随心所欲的访问Context的属性，无论是数据还是函数。因为只有组件自身或者相关的子组件可以清楚它能访问Context哪些属性，而相对于那些与组件无关的其他组件，无论是内部或者外部的 ，由于不清楚父组件链上各父组件的childContextTypes“声明”了哪些Context属性，所以没法通过contextTypes“申请”相关的属性。所以我理解为，给组件的作用域Context“带权限”，可以在一定程度上确保Context的可控性和影响范围。<br>在开发组件过程中，我们应该时刻关注这一点，不要随意的使用Context。</p>
<h2 id="3-3-不需要优先使用Context"><a href="#3-3-不需要优先使用Context" class="headerlink" title="3.3 不需要优先使用Context"></a>3.3 不需要优先使用Context</h2><p>作为React的高级API，React并<a href="https://reactjs.org/docs/context.html#why-not-to-use-context" target="_blank" rel="external">不推荐我们优先考虑使用Context</a>。我的理解是：</p>
<ul>
<li>Context目前还处于实验阶段，可能会在后面的发行版本中有大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来较大影响和麻烦，不建议在App中使用Context。</li>
<li>尽管不建议在App中使用Context，但对于组件而言，由于影响范围小于App，如果可以做到高内聚，不破坏组件树的依赖关系，那么还是可以考虑使用Context的。</li>
<li>对于组件之间的数据通信或者状态管理，优先考虑用props或者state解决，然后再考虑用其他第三方成熟库解决的，以上方法都不是最佳选择的时候，那么再考虑使用Context。</li>
<li>Context的更新需要通过setState()触发，但是这并不是可靠的。Context支持跨组件访问，但是，如果中间的子组件通过一些方法不响应更新，比如shouldComponentUpdate()返回false，那么不能保证Context的更新一定可达使用Context的子组件。因此，Context的可靠性需要关注。不过更新的问题，在新版的API中得以解决。</li>
</ul>
<p>简而言之，只要你能确保Context是可控的，使用Context并无大碍，甚至如果能够合理的应用，Context其实可以给React组件开发带来很强大的体验。</p>
<h2 id="3-4-用Context作为共享数据的媒介"><a href="#3-4-用Context作为共享数据的媒介" class="headerlink" title="3.4 用Context作为共享数据的媒介"></a>3.4 用Context作为共享数据的媒介</h2><p>官方所提到Context可以用来进行跨组件的数据通信。而我，把它理解为，好比一座桥，作为一种作为媒介进行数据共享。数据共享可以分两类：App级与组件级。</p>
<ul>
<li>App级的数据共享</li>
</ul>
<p>App根节点组件提供的Context对象可以看成是App级的全局作用域，所以，我们利用App根节点组件提供的Context对象创建一些App级的全局数据。现成的例子可以参考react-redux，以下是<provider>组件源码的核心实现：</provider></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createProvider</span>(<span class="params">storeKey = <span class="string">'store'</span>, subKey</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> subscriptionKey = subKey || <span class="string">`<span class="subst">$&#123;storeKey&#125;</span>Subscription`</span></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">        getChildContext() &#123;</div><div class="line">          <span class="keyword">return</span> &#123; [storeKey]: <span class="keyword">this</span>[storeKey], [subscriptionKey]: <span class="literal">null</span> &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">constructor</span>(props, context) &#123;</div><div class="line">          <span class="keyword">super</span>(props, context)</div><div class="line">          <span class="keyword">this</span>[storeKey] = props.store;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        render() &#123;</div><div class="line">          <span class="keyword">return</span> Children.only(<span class="keyword">this</span>.props.children)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    Provider.propTypes = &#123;</div><div class="line">        <span class="attr">store</span>: storeShape.isRequired,</div><div class="line">        <span class="attr">children</span>: PropTypes.element.isRequired,</div><div class="line">    &#125;</div><div class="line">    Provider.childContextTypes = &#123;</div><div class="line">        [storeKey]: storeShape.isRequired,</div><div class="line">        [subscriptionKey]: subscriptionShape,</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Provider</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> createProvider()</div></pre></td></tr></table></figure>
<p>App的根组件用<provider>组件包裹后，本质上就为App提供了一个全局的属性store，相当于在整个App范围内，共享store属性。当然，<provider>组件也可以包裹在其他组件中，在组件级的全局范围内共享store。</provider></provider></p>
<ul>
<li>组件级的数据共享</li>
</ul>
<p>如果组件的功能不能单靠组件自身来完成，还需要依赖额外的子组件，那么可以利用Context构建一个由多个子组件组合的组件。例如，react-router。<br>react-router的<router>自身并不能独立完成路由的操作和管理，因为导航链接和跳转的内容通常是分离的，因此还需要依赖<link>和<route>等子组件来一同完成路由的相关工作。为了让相关的子组件一同发挥作用，react-router的实现方案是利用Context在<router>、<link>以及<route>这些相关的组件之间共享一个router，进而完成路由的统一操作和管理。<br>下面截取<router>、<link>以及<route>这些相关的组件部分源码，以便更好的理解上述所说的。</route></router></route></router></route></router></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Router.js</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The public API for putting history on context.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> propTypes = &#123;</div><div class="line">    <span class="attr">history</span>: PropTypes.object.isRequired,</div><div class="line">    <span class="attr">children</span>: PropTypes.node</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> contextTypes = &#123;</div><div class="line">    <span class="attr">router</span>: PropTypes.object</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">    <span class="attr">router</span>: PropTypes.object.isRequired</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  getChildContext() &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">router</span>: &#123;</div><div class="line">        ...this.context.router,</div><div class="line">        <span class="attr">history</span>: <span class="keyword">this</span>.props.history,</div><div class="line">        <span class="attr">route</span>: &#123;</div><div class="line">          <span class="attr">location</span>: <span class="keyword">this</span>.props.history.location,</div><div class="line">          <span class="attr">match</span>: <span class="keyword">this</span>.state.match</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// ......</span></div><div class="line">  </div><div class="line">  componentWillMount() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; children, history &#125; = <span class="keyword">this</span>.props;</div><div class="line">    </div><div class="line">    <span class="comment">// ......</span></div><div class="line">    </div><div class="line">    <span class="keyword">this</span>.unlisten = history.listen(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">match</span>: <span class="keyword">this</span>.computeMatch(history.location.pathname)</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// ......</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>尽管源码还有其他的逻辑，但<router>的核心就是为子组件提供一个带有router属性的Context，同时监听history，一旦history发生变化，便通过setState()触发组件重新渲染。</router></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Link.js</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The public API for rendering a history-aware &lt;a&gt;.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// ......</span></div><div class="line">  </div><div class="line">  <span class="keyword">static</span> contextTypes = &#123;</div><div class="line">    <span class="attr">router</span>: PropTypes.shape(&#123;</div><div class="line">      <span class="attr">history</span>: PropTypes.shape(&#123;</div><div class="line">        <span class="attr">push</span>: PropTypes.func.isRequired,</div><div class="line">        <span class="attr">replace</span>: PropTypes.func.isRequired,</div><div class="line">        <span class="attr">createHref</span>: PropTypes.func.isRequired</div><div class="line">      &#125;).isRequired</div><div class="line">    &#125;).isRequired</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  handleClick = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.onClick) <span class="keyword">this</span>.props.onClick(event);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (</div><div class="line">      !event.defaultPrevented &amp;&amp;</div><div class="line">      event.button === <span class="number">0</span> &amp;&amp;</div><div class="line">      !<span class="keyword">this</span>.props.target &amp;&amp;</div><div class="line">      !isModifiedEvent(event)</div><div class="line">    ) &#123;</div><div class="line">      event.preventDefault();</div><div class="line">      <span class="comment">// 使用&lt;Router /&gt;组件提供的router实例</span></div><div class="line">      <span class="keyword">const</span> &#123; history &#125; = <span class="keyword">this</span>.context.router;</div><div class="line">      <span class="keyword">const</span> &#123; replace, to &#125; = <span class="keyword">this</span>.props;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (replace) &#123;</div><div class="line">        history.replace(to);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        history.push(to);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  </div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; replace, to, innerRef, ...props &#125; = <span class="keyword">this</span>.props;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> &#123; history &#125; = <span class="keyword">this</span>.context.router;</div><div class="line">    <span class="keyword">const</span> location =</div><div class="line">      <span class="keyword">typeof</span> to === <span class="string">"string"</span></div><div class="line">        ? createLocation(to, <span class="literal">null</span>, <span class="literal">null</span>, history.location)</div><div class="line">        : to;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> href = history.createHref(location);</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">a</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span> <span class="attr">href</span>=<span class="string">&#123;href&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;innerRef&#125;</span> /&gt;</span></span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><link>的核心就是渲染<a>标签，拦截<a>标签的点击事件，然后通过<router>共享的router对history进行路由操作，进而通知<router>重新渲染。</router></router></a></a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Route.js</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The public API for matching a single path and rendering.</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">// ......</span></div><div class="line">  </div><div class="line">  state = &#123;</div><div class="line">    <span class="attr">match</span>: <span class="keyword">this</span>.computeMatch(<span class="keyword">this</span>.props, <span class="keyword">this</span>.context.router)</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// 计算匹配的路径，匹配的话，会返回一个匹配对象，否则返回null</span></div><div class="line">  computeMatch(</div><div class="line">    &#123; computedMatch, location, path, strict, exact, sensitive &#125;,</div><div class="line">    router</div><div class="line">  ) &#123;</div><div class="line">    <span class="keyword">if</span> (computedMatch) <span class="keyword">return</span> computedMatch;</div><div class="line">    </div><div class="line">    <span class="comment">// ......</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> &#123; route &#125; = router;</div><div class="line">    <span class="keyword">const</span> pathname = (location || route.location).pathname;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> matchPath(pathname, &#123; path, strict, exact, sensitive &#125;, route.match);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// ......</span></div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; match &#125; = <span class="keyword">this</span>.state;</div><div class="line">    <span class="keyword">const</span> &#123; children, component, render &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="keyword">const</span> &#123; history, route, staticContext &#125; = <span class="keyword">this</span>.context.router;</div><div class="line">    <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || route.location;</div><div class="line">    <span class="keyword">const</span> props = &#123; match, location, history, staticContext &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (component) <span class="keyword">return</span> match ? React.createElement(component, props) : <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (render) <span class="keyword">return</span> match ? render(props) : <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">"function"</span>) <span class="keyword">return</span> children(props);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (children &amp;&amp; !isEmptyChildren(children))</div><div class="line">      <span class="keyword">return</span> React.Children.only(children);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><route>有一部分源码与<router>相似，可以实现路由的嵌套，但其核心是通过Context共享的router，判断是否匹配当前路由的路径，然后渲染组件。<br>通过上述的分析，可以看出，整个react-router其实就是围绕着<router>的Context来构建的。</router></router></route></p>
<h1 id="四、使用Context开发组件"><a href="#四、使用Context开发组件" class="headerlink" title="四、使用Context开发组件"></a>四、使用Context开发组件</h1><p>之前，通过Context开发过一个简单的组件，插槽分发组件。本章就借着这个插槽分发组件的开发经历，聊聊如何使用Context进行组件的开发。</p>
<h2 id="4-1-插槽分发组件"><a href="#4-1-插槽分发组件" class="headerlink" title="4.1 插槽分发组件"></a>4.1 插槽分发组件</h2><p>首先说说什么是插槽分发组件，这个概念最初是在Vuejs中认识的。插槽分发是一种通过组件的组合，将父组件的内容插入到子组件模板的技术，在Vuejs中叫做Slot。<br>为了让大家更加直观的理解这个概念，我从Vuejs搬运了一段关于插槽分发的Demo。<br>对于提供的插槽的组件<my-component>，模板如下：</my-component></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></div><div class="line">    只有在没有要分发的内容时显示</div><div class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>对于父组件，模板如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是更多的初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>最终渲染的结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是更多的初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到组件<my-component> 的<slot>节点最终被父组件中<my-component>节点下的内容所替换。</my-component></slot></my-component></p>
<p>Vuejs还支持具名插槽。</p>
<p>例如，一个布局组件<app-layout>：</app-layout></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>而在父组件模板中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">app-layout</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>这里可能是一个页面标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容的一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>这里有一些联系信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">app-layout</span>&gt;</span></div></pre></td></tr></table></figure>
<p>最终渲染的结果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里可能是一个页面标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容的一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里有一些联系信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>插槽分发的好处体现在，它可以让组件具有可抽象成模板的能力。组件自身只关心模板结构，具体的内容交给父组件去处理，同时，不打破HTML描述DOM结构的语法表达方式。我觉得这是一项很有意义的技术，可惜，React对于这项技术的支持不是那么友好。于是我便参考Vuejs的插槽分发组件，开发了一套基于React的插槽分发组件，可以让React组件也具模板化的能力。<br>对于<applayout>组件，我希望可以写成下面这样：</applayout></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppLayout</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> displayName = <span class="string">'AppLayout'</span></div><div class="line">  </div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在外层使用时，可以写成这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;AppLayout&gt;</div><div class="line">  &lt;AddOn slot="header"&gt;</div><div class="line">    &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt;</div><div class="line">  &lt;/AddOn&gt;</div><div class="line">  &lt;AddOn&gt;</div><div class="line">    &lt;p&gt;主要内容的一个段落。&lt;/p&gt;</div><div class="line">    &lt;p&gt;另一个段落。&lt;/p&gt;</div><div class="line">  &lt;/AddOn&gt;</div><div class="line">  &lt;AddOn slot="footer"&gt;</div><div class="line">    &lt;p&gt;这里有一些联系信息&lt;/p&gt;</div><div class="line">  &lt;/AddOn&gt;</div><div class="line">&lt;/AppLayout&gt;</div></pre></td></tr></table></figure>
<h2 id="4-1-组件的实现思路"><a href="#4-1-组件的实现思路" class="headerlink" title="4.1 组件的实现思路"></a>4.1 组件的实现思路</h2><p>根据前面所想的，先整理一下实现思路。<br>不难看出，插槽分发组件需要依靠两个子组件——插槽组件<slot>和分发组件<addon>。插槽组件，负责打桩，提供分发内容的坑位。分发组件，负责收集分发内容，并提供给插槽组件去渲染分发内容，相当于插槽的消费者。<br>显然，这里遇到了一个问题，<slot>组件与<addon>组件是独立的，如何将<addon>的内容填充到<slot>中呢？解决这个问题不难，两个独立的模块需要建立联系，就给他们建立一个桥梁。那么这个桥梁要如何搭建呢？回过头来看看之前的设想的代码。<br>对于<applayout>组件，希望写成下面这样：</applayout></slot></addon></addon></slot></addon></slot></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppLayout</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> displayName = <span class="string">'AppLayout'</span></div><div class="line">  </div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在外层使用时，写成这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;AppLayout&gt;</div><div class="line">  &lt;AddOn slot="header"&gt;</div><div class="line">    &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt;</div><div class="line">  &lt;/AddOn&gt;</div><div class="line">  &lt;AddOn&gt;</div><div class="line">    &lt;p&gt;主要内容的一个段落。&lt;/p&gt;</div><div class="line">    &lt;p&gt;另一个段落。&lt;/p&gt;</div><div class="line">  &lt;/AddOn&gt;</div><div class="line">  &lt;AddOn slot="footer"&gt;</div><div class="line">    &lt;p&gt;这里有一些联系信息&lt;/p&gt;</div><div class="line">  &lt;/AddOn&gt;</div><div class="line">&lt;/AppLayout&gt;</div></pre></td></tr></table></figure>
<p>无论是<slot>还是<addon>，其实都在<applayout>的作用域内。<slot>是<applayout>组件render()方法返回的组件节点，而<addon>则是<applayout>的children节点，所以，可以将<applayout>视为<slot>与<addon>的桥梁的角色。那么，<applayout>通过什么给<slot>和<addon>建立联系呢？这里就用到本文的主角——Context。接下来的问题就是，如何使用Context给<slot>和<addon>建立联系？<br>前面提到了<applayout>这座桥梁。在外层组件，<applayout>负责通过<addon>收集为插槽填充的内容。<applayout>自身借助Context定义一个获取填充内容的接口。在渲染的时候，因为<slot>是<applayout>渲染的节点，所以，<slot>可以通过Context获取到<applayout>定义的获取填充内容的接口，然后通过这个接口，获取到填充内容进行渲染。</applayout></slot></applayout></slot></applayout></addon></applayout></applayout></addon></slot></addon></slot></applayout></addon></slot></applayout></applayout></addon></applayout></slot></applayout></addon></slot></p>
<h2 id="4-2-按照思路实现插槽分发组件"><a href="#4-2-按照思路实现插槽分发组件" class="headerlink" title="4.2 按照思路实现插槽分发组件"></a>4.2 按照思路实现插槽分发组件</h2><p>由于<addon>是<applayout>的children节点，并且<addon>是特定的组件，我们可以通过name或者displayName识别出来，所以，<applayout>在渲染之前，也就是render()的return之前，对children进行遍历，以slot的值作为key，将每一个<addon>的children缓存下来。如果<addon>没有设置slot，那么将其视为给非具名的<slot>填充内容，我们可以给这些非具名的插槽定一个key，比如叫$$default。<br>对于<applayout>，代码大致如下：</applayout></slot></addon></addon></applayout></addon></applayout></addon></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppLayout</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">    <span class="attr">requestAddOnRenderer</span>: PropTypes.func</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 用于缓存每个&lt;AddOn /&gt;的内容</span></div><div class="line">  addOnRenderers = &#123;&#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 通过Context为子节点提供接口</span></div><div class="line">  getChildContext () &#123;</div><div class="line">    <span class="keyword">const</span> requestAddOnRenderer = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.addOnRenderers[name]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">        <span class="keyword">this</span>.addOnRenderers[name]</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      requestAddOnRenderer</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">const</span> &#123;</div><div class="line">      children,</div><div class="line">      ...restProps</div><div class="line">    &#125; = <span class="keyword">this</span>.props</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (children) &#123;</div><div class="line">      <span class="comment">// 以k-v的方式缓存&lt;AddOn /&gt;的内容</span></div><div class="line">      <span class="keyword">const</span> arr = React.Children.toArray(children)</div><div class="line">      <span class="keyword">const</span> nameChecked = []</div><div class="line">      <span class="keyword">this</span>.addOnRenderers = &#123;&#125;</div><div class="line">      arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> itemType = item.type</div><div class="line">        <span class="keyword">if</span> (item.type.displayName === <span class="string">'AddOn'</span>) &#123;</div><div class="line">          <span class="keyword">const</span> slotName = item.props.slot || <span class="string">'$$default'</span></div><div class="line">          <span class="comment">// 确保内容唯一性</span></div><div class="line">          <span class="keyword">if</span> (nameChecked.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === stubName) !== <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Slot(<span class="subst">$&#123;slotName&#125;</span>) has been occupied`</span>)</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">this</span>.addOnRenderers[stubName] = item.props.children</div><div class="line">          nameChecked.push(stubName)</div><div class="line">        &#125;</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><applayout>定义了一个Context接口requestAddOnRenderer()，requestAddOnRenderer()接口根据name返回一个函数，这个返回的函数会根据name访问addOnRenderers的属性，addOnRenderers就是<addon>的内容缓存对象。</addon></applayout></p>
<p><slot>的实现很简单，代码如下：</slot></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// props,context</span></div><div class="line"><span class="keyword">const</span> Slot = <span class="function">(<span class="params">&#123; name, children &#125;, &#123; requestAddOnRenderer &#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> addOnRenderer = requestAddOnRenderer(name)</div><div class="line">  <span class="keyword">return</span> (addOnRenderer &amp;&amp; addOnRenderer()) ||</div><div class="line">    children ||</div><div class="line">    <span class="literal">null</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Slot.displayName = <span class="string">'Slot'</span></div><div class="line">Slot.contextTypes = &#123; <span class="attr">requestAddOnRenderer</span>: PropTypes.func &#125;</div><div class="line">Slot.propTypes = &#123; <span class="attr">name</span>: PropTypes.string &#125;</div><div class="line">Slot.defaultProps = &#123; <span class="attr">name</span>: <span class="string">'$$default'</span> &#125;</div></pre></td></tr></table></figure>
<p>可以看到<slot>通过context获取到<applayout>提供的接口requestAddOnRenderer()，最终渲染的主要对象就是缓存在<applayout>中的<addon>的内容。如果没有获取到指定的<addon>的内容，则渲染<slot>自身的children。</slot></addon></addon></applayout></applayout></slot></p>
<p><addon>更简单：</addon></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> AddOn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">null</span></div><div class="line"></div><div class="line">AddOn.propTypes = &#123; <span class="attr">slot</span>: PropTypes.string &#125;</div><div class="line">AddOn.defaultTypes = &#123; <span class="attr">slot</span>: <span class="string">'$$default'</span> &#125;</div><div class="line">AddOn.displayName = <span class="string">'AddOn'</span></div></pre></td></tr></table></figure>
<p><addon>不做任何事情，仅仅返回null，它的作用就是让<applayout>缓存分发给插槽的内容。</applayout></addon></p>
<h2 id="4-3-可以让更具通用性"><a href="#4-3-可以让更具通用性" class="headerlink" title="4.3 可以让更具通用性"></a>4.3 可以让<applayout>更具通用性</applayout></h2><p>通过上文的代码，基本将<applayout>改造成了一个具备插槽分发能力的组件，但是很明显的，<applayout>并不具备通用性，我们可以将它提升成一个独立通用的组件。<br>我给这个组件命名为SlotProvider</applayout></applayout></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> component.displayName || component.name || <span class="string">'component'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> slotProviderHoC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> displayName = <span class="string">`SlotProvider(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></div><div class="line"></div><div class="line">    <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">      <span class="attr">requestAddOnRenderer</span>: PropTypes.func</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 用于缓存每个&lt;AddOn /&gt;的内容</span></div><div class="line">    addOnRenderers = &#123;&#125;</div><div class="line">  </div><div class="line">    <span class="comment">// 通过Context为子节点提供接口</span></div><div class="line">    getChildContext () &#123;</div><div class="line">      <span class="keyword">const</span> requestAddOnRenderer = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.addOnRenderers[name]) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="literal">undefined</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">          <span class="keyword">this</span>.addOnRenderers[name]</div><div class="line">        )</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> &#123;</div><div class="line">        requestAddOnRenderer</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render () &#123;</div><div class="line">      <span class="keyword">const</span> &#123;</div><div class="line">        children,</div><div class="line">        ...restProps</div><div class="line">      &#125; = <span class="keyword">this</span>.props</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (children) &#123;</div><div class="line">        <span class="comment">// 以k-v的方式缓存&lt;AddOn /&gt;的内容</span></div><div class="line">        <span class="keyword">const</span> arr = React.Children.toArray(children)</div><div class="line">        <span class="keyword">const</span> nameChecked = []</div><div class="line">        <span class="keyword">this</span>.addOnRenderers = &#123;&#125;</div><div class="line">        arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">const</span> itemType = item.type</div><div class="line">          <span class="keyword">if</span> (item.type.displayName === <span class="string">'AddOn'</span>) &#123;</div><div class="line">            <span class="keyword">const</span> slotName = item.props.slot || <span class="string">'$$default'</span></div><div class="line">            <span class="comment">// 确保内容唯一性</span></div><div class="line">            <span class="keyword">if</span> (nameChecked.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === stubName) !== <span class="number">-1</span>) &#123;</div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Slot(<span class="subst">$&#123;slotName&#125;</span>) has been occupied`</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.addOnRenderers[stubName] = item.props.children</div><div class="line">            nameChecked.push(stubName)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...restProps</span>&#125; /&gt;</span>)</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export const SlotProvider = slotProviderHoC</div></pre></td></tr></table></figure>
<p>使用React的高阶组件对原来的<applayout>进行改造，将其转变为一个独立通用的组件。对于原来的<applayout>，可以使用这个SlotProvider高阶组件，转换成一个具备插槽分发能力的组件。</applayout></applayout></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; SlotProvider &#125; <span class="keyword">from</span> <span class="string">'./SlotProvider.js'</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppLayout</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> displayName = <span class="string">'AppLayout'</span></div><div class="line">  </div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="name">header</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">main</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">main</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">footer</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">Slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">Slot</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    )</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> SlotProvider(AppLayout)</div></pre></td></tr></table></figure>
<p>通过以上的经历，可以看到，当设计开发一个组件时，</p>
<ul>
<li>组件可能需要由一个根组件和多个子组件一起合作来完成组件功能。比如插槽分发组件实际上需要SlotProvider与<slot>和<addon>一起配合使用，SlotProvider作为根组件，而<slot>和<addon>都算是子组件。</addon></slot></addon></slot></li>
<li>子组件相对于根组件的位置或者子组件之间的位置是不确定。对于SlotProvider而言，<slot>的位置是不确定的，它会处在被SlotProvider这个高阶组件所包裹的组件的模板的任何位置，而对于<slot>和<addon>，他们直接的位置也不确定，一个在SlotProvider包装的组件的内部，另一个是SlotProvider的children。</addon></slot></slot></li>
<li>子组件之间需要依赖一些全局态的API或者数据，比如<slot>实际渲染的内容来自于SlotProvider收集到的<addon>的内容。</addon></slot></li>
</ul>
<p>这时我们就需要借助一个中间者作为媒介来共享数据，相比额外引入redux这些第三方模块，直接使用Context可以更优雅。</p>
<h2 id="4-5-尝试一下新版本的Context-API"><a href="#4-5-尝试一下新版本的Context-API" class="headerlink" title="4.5 尝试一下新版本的Context API"></a>4.5 尝试一下新版本的Context API</h2><p>使用新版的Context API对之前的插槽分发组件进行改造。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// SlotProvider.js</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDisplayName</span> (<span class="params">component</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> component.displayName || component.name || <span class="string">'component'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> SlotContext = React.createContext(&#123;</div><div class="line">  <span class="attr">requestAddOnRenderer</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> slotProviderHoC = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> displayName = <span class="string">`SlotProvider(<span class="subst">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></div><div class="line"></div><div class="line">    <span class="comment">// 用于缓存每个&lt;AddOn /&gt;的内容</span></div><div class="line">    addOnRenderers = &#123;&#125;</div><div class="line">  </div><div class="line">    requestAddOnRenderer = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</div><div class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.addOnRenderers[name]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">undefined</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">        <span class="keyword">this</span>.addOnRenderers[name]</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render () &#123;</div><div class="line">      <span class="keyword">const</span> &#123;</div><div class="line">        children,</div><div class="line">        ...restProps</div><div class="line">      &#125; = <span class="keyword">this</span>.props</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (children) &#123;</div><div class="line">        <span class="comment">// 以k-v的方式缓存&lt;AddOn /&gt;的内容</span></div><div class="line">        <span class="keyword">const</span> arr = React.Children.toArray(children)</div><div class="line">        <span class="keyword">const</span> nameChecked = []</div><div class="line">        <span class="keyword">this</span>.addOnRenderers = &#123;&#125;</div><div class="line">        arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</div><div class="line">          <span class="keyword">const</span> itemType = item.type</div><div class="line">          <span class="keyword">if</span> (item.type.displayName === <span class="string">'AddOn'</span>) &#123;</div><div class="line">            <span class="keyword">const</span> slotName = item.props.slot || <span class="string">'$$default'</span></div><div class="line">            <span class="comment">// 确保内容唯一性</span></div><div class="line">            <span class="keyword">if</span> (nameChecked.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item === stubName) !== <span class="number">-1</span>) &#123;</div><div class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Slot(<span class="subst">$&#123;slotName&#125;</span>) has been occupied`</span>)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>.addOnRenderers[stubName] = item.props.children</div><div class="line">            nameChecked.push(stubName)</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="keyword">return</span> (</div><div class="line">        &lt;SlotContext.Provider value=&#123;</div><div class="line">            requestAddOnRenderer: this.requestAddOnRenderer</div><div class="line">          &#125;&gt;</div><div class="line">          &lt;WrappedComponent &#123;...restProps&#125; /&gt;</div><div class="line">        &lt;/SlotContext.Provider&gt;</div><div class="line">      )</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export const SlotProvider = slotProviderHoC</div></pre></td></tr></table></figure>
<p>移除了之前的childContextTypes和getChildContext()，除了局部的调整，整体核心的东西没有大变化。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Slot.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; SlotContext &#125; <span class="keyword">from</span> <span class="string">'./SlotProvider.js'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> Slot = <span class="function">(<span class="params">&#123; name, children &#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">SlotContext.Consumer</span>&gt;</span></span></div><div class="line">      &#123;(context) =&gt; &#123;</div><div class="line">        const addOnRenderer = requestAddOnRenderer(name)</div><div class="line">          return (addOnRenderer &amp;&amp; addOnRenderer()) ||</div><div class="line">            children ||</div><div class="line">            null</div><div class="line">      &#125;&#125;</div><div class="line">    <span class="tag">&lt;/<span class="name">SlotContext.Consumer</span>&gt;</span></div><div class="line">  )</div><div class="line">&#125;</div><div class="line"></div><div class="line">Slot.displayName = 'Slot'</div><div class="line">Slot.propTypes = &#123; name: PropTypes.string &#125;</div><div class="line">Slot.defaultProps = &#123; name: '$$default' &#125;</div></pre></td></tr></table></figure>
<p>由于之前就按照生产者消费者的模式来使用Context，加上组件自身也比较简单，因此使用新的API进行改造后，差别不大。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul>
<li>相比props和state，React的Context可以实现跨层级的组件通信。</li>
<li>Context API的使用基于生产者消费者模式。生产者一方，通过组件静态属性childContextTypes声明，然后通过实例方法getChildContext()创建Context对象。消费者一方，通过组件静态属性contextTypes申请要用到的Context属性，然后通过实例的context访问Context的属性。</li>
<li>使用Context需要多一些思考，不建议在App中使用Context，但如果开发组件过程中可以确保组件的内聚性，可控可维护，不破坏组件树的依赖关系，影响范围小，可以考虑使用Context解决一些问题。</li>
<li>通过Context暴露API或许在一定程度上给解决一些问题带来便利，但个人认为不是一个很好的实践，需要慎重。</li>
<li>旧版本的Context的更新需要依赖setState()，是不可靠的，不过这个问题在新版的API中得以解决。</li>
<li>可以把Context当做组件的作用域来看待，但是需要关注Context的可控性和影响范围，使用之前，先分析是否真的有必要使用，避免过度使用所带来的一些副作用。</li>
<li>可以把Context当做媒介，进行App级或者组件级的数据共享。</li>
<li>设计开发一个组件，如果这个组件需要多个组件关联组合的，使用Context或许可以更加优雅。</li>
</ul>
<h1 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h1><ul>
<li>Context - <a href="https://reactjs.org/docs/context.html" target="_blank" rel="external">https://reactjs.org/docs/context.html</a></li>
<li>React 16.3来了：带着全新的Context API - <a href="http://cnodejs.org/topic/5a7bd5c4497a08f571384f03" target="_blank" rel="external">http://cnodejs.org/topic/5a7bd5c4497a08f571384f03</a></li>
<li>Content Distribution with Slots - <a href="https://vuejs.org/v2/guide/components.html#Content-Distribution-with-Slots" target="_blank" rel="external">https://vuejs.org/v2/guide/components.html#Content-Distribution-with-Slots</a></li>
<li>题图 - <a href="http://www.mafengwo.cn/poi/36580.html" target="_blank" rel="external">http://www.mafengwo.cn/poi/36580.html</a></li>
</ul>
<p>本文引用自 <a href="https://juejin.im/post/5a90e0545188257a63112977#heading-4" target="_blank" rel="external">https://juejin.im/post/5a90e0545188257a63112977#heading-4</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/react-context/" rel="tag"># --react  context</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/21/react-HOC/" rel="next" title="深入浅出React高阶组件">
                <i class="fa fa-chevron-left"></i> 深入浅出React高阶组件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/23/react-router/" rel="prev" title="深入理解 react-router 路由系统">
                深入理解 react-router 路由系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Jacob" />
          <p class="site-author-name" itemprop="name">Jacob</p>
           
              <p class="site-description motion-element" itemprop="description">记录生活点滴</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/your-user-name" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/your-user-name" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/your-user-name" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一、前言"><span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#二、初识React-Context"><span class="nav-text">二、初识React Context</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-官方对于Context的定义"><span class="nav-text">2.1 官方对于Context的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-如何使用Context"><span class="nav-text">2.2 如何使用Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-几个可以直接获取Context的地方"><span class="nav-text">3.3 几个可以直接获取Context的地方</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#三、我对Context的理解"><span class="nav-text">三、我对Context的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-把Context当做组件作用域"><span class="nav-text">3.1 把Context当做组件作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-关注Context的可控性和影响范围"><span class="nav-text">3.2 关注Context的可控性和影响范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-不需要优先使用Context"><span class="nav-text">3.3 不需要优先使用Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-用Context作为共享数据的媒介"><span class="nav-text">3.4 用Context作为共享数据的媒介</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#四、使用Context开发组件"><span class="nav-text">四、使用Context开发组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-插槽分发组件"><span class="nav-text">4.1 插槽分发组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-组件的实现思路"><span class="nav-text">4.1 组件的实现思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-按照思路实现插槽分发组件"><span class="nav-text">4.2 按照思路实现插槽分发组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-可以让更具通用性"><span class="nav-text">4.3 可以让更具通用性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-尝试一下新版本的Context-API"><span class="nav-text">4.5 尝试一下新版本的Context API</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#五、总结"><span class="nav-text">五、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#六、引用"><span class="nav-text">六、引用</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jacob</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://ZheningLin.github.io/2019/02/22/react-context/';
          this.page.identifier = '2019/02/22/react-context/';
          this.page.title = '对 React Context 的理解以及应用';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("p66dtkiI4ISfwBtjQrYYOuGg-gzGzoHsz", "5gyWux8Xrw1X9920CkoKBueE");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
